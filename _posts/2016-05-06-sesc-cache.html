---
layout:     post
title:      "SESC源码阅读——Caches"
date:       2016-05-06
author:     "yuchen"
header-img: "img/post-bg-odroid.jpg"
tags:
    - SESC
    - Caches
---
<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>sesc-src-read-3.html</title>
  <meta name="generator" content="Haroopad 0.13.1" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <style>div.oembedall-githubrepos{border:1px solid #DDD;border-radius:4px;list-style-type:none;margin:0 0 10px;padding:8px 10px 0;font:13.34px/1.4 helvetica,arial,freesans,clean,sans-serif;width:452px;background-color:#fff}div.oembedall-githubrepos .oembedall-body{background:-moz-linear-gradient(center top,#FAFAFA,#EFEFEF);background:-webkit-gradient(linear,left top,left bottom,from(#FAFAFA),to(#EFEFEF));border-bottom-left-radius:4px;border-bottom-right-radius:4px;border-top:1px solid #EEE;margin-left:-10px;margin-top:8px;padding:5px 10px;width:100%}div.oembedall-githubrepos h3{font-size:14px;margin:0;padding-left:18px;white-space:nowrap}div.oembedall-githubrepos p.oembedall-description{color:#444;font-size:12px;margin:0 0 3px}div.oembedall-githubrepos p.oembedall-updated-at{color:#888;font-size:11px;margin:0}div.oembedall-githubrepos ul.oembedall-repo-stats{border:none;float:right;font-size:11px;font-weight:700;padding-left:15px;position:relative;z-index:5;margin:0}div.oembedall-githubrepos ul.oembedall-repo-stats li{border:none;color:#666;display:inline-block;list-style-type:none;margin:0!important}div.oembedall-githubrepos ul.oembedall-repo-stats li a{background-color:transparent;border:none;color:#666!important;background-position:5px -2px;background-repeat:no-repeat;border-left:1px solid #DDD;display:inline-block;height:21px;line-height:21px;padding:0 5px 0 23px}div.oembedall-githubrepos ul.oembedall-repo-stats li:first-child a{border-left:medium none;margin-right:-3px}div.oembedall-githubrepos ul.oembedall-repo-stats li a:hover{background:5px -27px no-repeat #4183C4;color:#FFF!important;text-decoration:none}div.oembedall-githubrepos ul.oembedall-repo-stats li:first-child a:hover{border-bottom-left-radius:3px;border-top-left-radius:3px}ul.oembedall-repo-stats li:last-child a:hover{border-bottom-right-radius:3px;border-top-right-radius:3px}span.oembedall-closehide{background-color:#aaa;border-radius:2px;cursor:pointer;margin-right:3px}div.oembedall-container{margin-top:5px;text-align:left}.oembedall-ljuser{font-weight:700}.oembedall-ljuser img{vertical-align:bottom;border:0;padding-right:1px}.oembedall-stoqembed{border-bottom:1px dotted #999;float:left;overflow:hidden;width:730px;line-height:1;background:#FFF;color:#000;font-family:Arial,Liberation Sans,DejaVu Sans,sans-serif;font-size:80%;text-align:left;margin:0;padding:0}.oembedall-stoqembed a{color:#07C;text-decoration:none;margin:0;padding:0}.oembedall-stoqembed a:hover{text-decoration:underline}.oembedall-stoqembed a:visited{color:#4A6B82}.oembedall-stoqembed h3{font-family:Trebuchet MS,Liberation Sans,DejaVu Sans,sans-serif;font-size:130%;font-weight:700;margin:0;padding:0}.oembedall-stoqembed .oembedall-reputation-score{color:#444;font-size:120%;font-weight:700;margin-right:2px}.oembedall-stoqembed .oembedall-user-info{height:35px;width:185px}.oembedall-stoqembed .oembedall-user-info .oembedall-user-gravatar32{float:left;height:32px;width:32px}.oembedall-stoqembed .oembedall-user-info .oembedall-user-details{float:left;margin-left:5px;overflow:hidden;white-space:nowrap;width:145px}.oembedall-stoqembed .oembedall-question-hyperlink{font-weight:700}.oembedall-stoqembed .oembedall-stats{background:#EEE;margin:0 0 0 7px;padding:4px 7px 6px;width:58px}.oembedall-stoqembed .oembedall-statscontainer{float:left;margin-right:8px;width:86px}.oembedall-stoqembed .oembedall-votes{color:#555;padding:0 0 7px;text-align:center}.oembedall-stoqembed .oembedall-vote-count-post{font-size:240%;color:#808185;display:block;font-weight:700}.oembedall-stoqembed .oembedall-views{color:#999;padding-top:4px;text-align:center}.oembedall-stoqembed .oembedall-status{margin-top:-3px;padding:4px 0;text-align:center;background:#75845C;color:#FFF}.oembedall-stoqembed .oembedall-status strong{color:#FFF;display:block;font-size:140%}.oembedall-stoqembed .oembedall-summary{float:left;width:635px}.oembedall-stoqembed .oembedall-excerpt{line-height:1.2;margin:0;padding:0 0 5px}.oembedall-stoqembed .oembedall-tags{float:left;line-height:18px}.oembedall-stoqembed .oembedall-tags a:hover{text-decoration:none}.oembedall-stoqembed .oembedall-post-tag{background-color:#E0EAF1;border-bottom:1px solid #3E6D8E;border-right:1px solid #7F9FB6;color:#3E6D8E;font-size:90%;line-height:2.4;margin:2px 2px 2px 0;padding:3px 4px;text-decoration:none;white-space:nowrap}.oembedall-stoqembed .oembedall-post-tag:hover{background-color:#3E6D8E;border-bottom:1px solid #37607D;border-right:1px solid #37607D;color:#E0EAF1}.oembedall-stoqembed .oembedall-fr{float:right}.oembedall-stoqembed .oembedall-statsarrow{background-image:url(http://cdn.sstatic.net/stackoverflow/img/sprites.png?v=3);background-repeat:no-repeat;overflow:hidden;background-position:0 -435px;float:right;height:13px;margin-top:12px;width:7px}.oembedall-facebook1{border:1px solid #1A3C6C;padding:0;font:13.34px/1.4 verdana;width:500px}.oembedall-facebook2{background-color:#627add}.oembedall-facebook2 a{color:#e8e8e8;text-decoration:none}.oembedall-facebookBody{background-color:#fff;vertical-align:top;padding:5px}.oembedall-facebookBody .contents{display:inline-block;width:100%}.oembedall-facebookBody div img{float:left;margin-right:5px}div.oembedall-lanyard{-webkit-box-shadow:none;-webkit-transition-delay:0s;-webkit-transition-duration:.4000000059604645s;-webkit-transition-property:width;-webkit-transition-timing-function:cubic-bezier(0.42,0,.58,1);background-attachment:scroll;background-clip:border-box;background-color:transparent;background-image:none;background-origin:padding-box;border-width:0;box-shadow:none;color:#112644;display:block;float:left;font-family:'Trebuchet MS',Trebuchet,sans-serif;font-size:16px;height:253px;line-height:19px;margin:0;max-width:none;min-height:0;outline:#112644 0;overflow-x:visible;overflow-y:visible;padding:0;position:relative;text-align:left;vertical-align:baseline;width:804px}div.oembedall-lanyard .tagline{font-size:1.5em}div.oembedall-lanyard .wrapper{overflow:hidden;clear:both}div.oembedall-lanyard .split{float:left;display:inline}div.oembedall-lanyard .prominent-place .flag:active,div.oembedall-lanyard .prominent-place .flag:focus,div.oembedall-lanyard .prominent-place .flag:hover,div.oembedall-lanyard .prominent-place .flag:link,div.oembedall-lanyard .prominent-place .flag:visited{float:left;display:block;width:48px;height:48px;position:relative;top:-5px;margin-right:10px}div.oembedall-lanyard .place-context{font-size:.889em}div.oembedall-lanyard .prominent-place .sub-place{display:block}div.oembedall-lanyard .prominent-place{font-size:1.125em;line-height:1.1em;font-weight:400}div.oembedall-lanyard .main-date{color:#8CB4E0;font-weight:700;line-height:1.1}div.oembedall-lanyard .first{width:48.57%;margin:0 0 0 2.857%}.mermaid .label{color:#333}.node circle,.node polygon,.node rect{fill:#cde498;stroke:#13540c;stroke-width:1px}.edgePath .path{stroke:green;stroke-width:1.5px}.cluster rect{fill:#cdffb2;rx:40;stroke:#6eaa49;stroke-width:1px}.cluster text{fill:#333}.actor{stroke:#13540c;fill:#cde498}text.actor{fill:#000;stroke:none}.actor-line{stroke:grey}.messageLine0{stroke-width:1.5;stroke-dasharray:"2 2";marker-end:"url(#arrowhead)";stroke:#333}.messageLine1{stroke-width:1.5;stroke-dasharray:"2 2";stroke:#333}#arrowhead{fill:#333}#crosshead path{fill:#333!important;stroke:#333!important}.messageText{fill:#333;stroke:none}.labelBox{stroke:#326932;fill:#cde498}.labelText,.loopText{fill:#000;stroke:none}.loopLine{stroke-width:2;stroke-dasharray:"2 2";marker-end:"url(#arrowhead)";stroke:#326932}.note{stroke:#6eaa49;fill:#fff5ad}.noteText{fill:#000;stroke:none;font-family:'trebuchet ms',verdana,arial;font-size:14px}.section{stroke:none;opacity:.2}.section0,.section2{fill:#6eaa49}.section1,.section3{fill:#fff;opacity:.2}.sectionTitle0,.sectionTitle1,.sectionTitle2,.sectionTitle3{fill:#333}.sectionTitle{text-anchor:start;font-size:11px;text-height:14px}.grid .tick{stroke:lightgrey;opacity:.3;shape-rendering:crispEdges}.grid path{stroke-width:0}.today{fill:none;stroke:red;stroke-width:2px}.task{stroke-width:2}.taskText{text-anchor:middle;font-size:11px}.taskTextOutsideRight{fill:#000;text-anchor:start;font-size:11px}.taskTextOutsideLeft{fill:#000;text-anchor:end;font-size:11px}.taskText0,.taskText1,.taskText2,.taskText3{fill:#fff}.task0,.task1,.task2,.task3{fill:#487e3a;stroke:#13540c}.taskTextOutside0,.taskTextOutside1,.taskTextOutside2,.taskTextOutside3{fill:#000}.active0,.active1,.active2,.active3{fill:#cde498;stroke:#13540c}.activeText0,.activeText1,.activeText2,.activeText3{fill:#000!important}.done0,.done1,.done2,.done3{stroke:grey;fill:lightgrey;stroke-width:2}.doneText0,.doneText1,.doneText2,.doneText3{fill:#000!important}.crit0,.crit1,.crit2,.crit3{stroke:#f88;fill:red;stroke-width:2}.activeCrit0,.activeCrit1,.activeCrit2,.activeCrit3{stroke:#f88;fill:#cde498;stroke-width:2}.doneCrit0,.doneCrit1,.doneCrit2,.doneCrit3{stroke:#f88;fill:lightgrey;stroke-width:2;cursor:pointer;shape-rendering:crispEdges}.activeCritText0,.activeCritText1,.activeCritText2,.activeCritText3,.doneCritText0,.doneCritText1,.doneCritText2,.doneCritText3{fill:#000!important}.titleText{text-anchor:middle;font-size:18px;fill:#000}text{font-family:'trebuchet ms',verdana,arial;font-size:14px}html{height:100%}body{margin:0!important;padding:5px 20px 26px!important;background-color:#fff;font-family:"Lucida Grande","Segoe UI","Apple SD Gothic Neo","Malgun Gothic","Lucida Sans Unicode",Helvetica,Arial,sans-serif;font-size:.9em;overflow-x:hidden;overflow-y:auto}br,h1,h2,h3,h4,h5,h6{clear:both}hr.page{background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x;border:0;height:3px;padding:0}hr.underscore{border-top-style:dashed!important}body >:first-child{margin-top:0!important}img.plugin{box-shadow:0 1px 3px rgba(0,0,0,.1);border-radius:3px}iframe{border:0}figure{-webkit-margin-before:0;-webkit-margin-after:0;-webkit-margin-start:0;-webkit-margin-end:0}kbd{border:1px solid #aaa;-moz-border-radius:2px;-webkit-border-radius:2px;border-radius:2px;-moz-box-shadow:1px 2px 2px #ddd;-webkit-box-shadow:1px 2px 2px #ddd;box-shadow:1px 2px 2px #ddd;background-color:#f9f9f9;background-image:-moz-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:-o-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:-webkit-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:linear-gradient(top,#eee,#f9f9f9,#eee);padding:1px 3px;font-family:inherit;font-size:.85em}.oembeded .oembed_photo{display:inline-block}img[data-echo]{margin:25px 0;width:100px;height:100px;background:url(../img/ajax.gif) center center no-repeat #fff}.spinner{display:inline-block;width:10px;height:10px;margin-bottom:-.1em;border:2px solid rgba(0,0,0,.5);border-top-color:transparent;border-radius:100%;-webkit-animation:spin 1s infinite linear;animation:spin 1s infinite linear}.spinner:after{content:'';display:block;width:0;height:0;position:absolute;top:-6px;left:0;border:4px solid transparent;border-bottom-color:rgba(0,0,0,.5);-webkit-transform:rotate(45deg);transform:rotate(45deg)}@-webkit-keyframes spin{to{-webkit-transform:rotate(360deg)}}@keyframes spin{to{transform:rotate(360deg)}}p.toc{margin:0!important}p.toc ul{padding-left:10px}p.toc>ul{padding:10px;margin:0 10px;display:inline-block;border:1px solid #ededed;border-radius:5px}p.toc li,p.toc ul{list-style-type:none}p.toc li{width:100%;padding:0;overflow:hidden}p.toc li a::after{content:"."}p.toc li a:before{content:"• "}p.toc h5{text-transform:uppercase}p.toc .title{float:left;padding-right:3px}p.toc .number{margin:0;float:right;padding-left:3px;background:#fff;display:none}input.task-list-item{margin-left:-1.62em}.markdown{font-family:"Hiragino Sans GB","Microsoft YaHei",STHeiti,SimSun,"Lucida Grande","Lucida Sans Unicode","Lucida Sans",'Segoe UI',AppleSDGothicNeo-Medium,'Malgun Gothic',Verdana,Tahoma,sans-serif;padding:20px}.markdown a{text-decoration:none;vertical-align:baseline}.markdown a:hover{text-decoration:underline}.markdown h1{font-size:2.2em;font-weight:700;margin:1.5em 0 1em}.markdown h2{font-size:1.8em;font-weight:700;margin:1.275em 0 .85em}.markdown h3{font-size:1.6em;font-weight:700;margin:1.125em 0 .75em}.markdown h4{font-size:1.4em;font-weight:700;margin:.99em 0 .66em}.markdown h5{font-size:1.2em;font-weight:700;margin:.855em 0 .57em}.markdown h6{font-size:1em;font-weight:700;margin:.75em 0 .5em}.markdown h1+p,.markdown h1:first-child,.markdown h2+p,.markdown h2:first-child,.markdown h3+p,.markdown h3:first-child,.markdown h4+p,.markdown h4:first-child,.markdown h5+p,.markdown h5:first-child,.markdown h6+p,.markdown h6:first-child{margin-top:0}.markdown hr{border:1px solid #ccc}.markdown p{margin:1em 0;word-wrap:break-word}.markdown ol{list-style-type:decimal}.markdown li{display:list-item;line-height:1.4em}.markdown blockquote{margin:1em 20px}.markdown blockquote>:first-child{margin-top:0}.markdown blockquote>:last-child{margin-bottom:0}.markdown blockquote cite:before{content:'\2014 \00A0'}.markdown .code{border-radius:3px;word-wrap:break-word}.markdown pre{border-radius:3px;word-wrap:break-word;border:1px solid #ccc;overflow:auto;padding:.5em}.markdown pre code{border:0;display:block}.markdown pre>code{font-family:Consolas,Inconsolata,Courier,monospace;font-weight:700;white-space:pre;margin:0}.markdown code{border-radius:3px;word-wrap:break-word;border:1px solid #ccc;padding:0 5px;margin:0 2px}.markdown img{max-width:100%}.markdown mark{color:#000;background-color:#fcf8e3}.markdown table{padding:0;border-collapse:collapse;border-spacing:0;margin-bottom:16px}.markdown table tr td,.markdown table tr th{border:1px solid #ccc;margin:0;padding:6px 13px}.markdown table tr th{font-weight:700}.markdown table tr th>:first-child{margin-top:0}.markdown table tr th>:last-child{margin-bottom:0}.markdown table tr td>:first-child{margin-top:0}.markdown table tr td>:last-child{margin-bottom:0}.solarized-light{padding:20px;color:#737373;font-size:15px;background:#fdf6e3;-webkit-font-smoothing:antialiased}.solarized-light a{color:#1e6ea7}.solarized-light a:hover{color:#268bd2}.solarized-light h1,.solarized-light h2,.solarized-light h3,.solarized-light h4,.solarized-light h5{color:#b58900}.solarized-light h2{border-bottom:1px solid #f6d784;line-height:1.7em}.solarized-light h6{color:#9c7600}.solarized-light hr{border:1px solid #fae7b3}.solarized-light pre>code{font-size:.9em}.solarized-light blockquote{border-left:4px solid #fae7b3;padding:0 15px;font-style:italic}.solarized-light table{background-color:#fdf4dd}.solarized-light table tr td,.solarized-light table tr th{border:1px solid #fae7b3}.solarized-light table tr:nth-child(2n){background-color:#fef8ea}.hljs{display:block;overflow-x:auto;padding:.5em;background:#fff;color:#000;-webkit-text-size-adjust:none}.hljs-comment,.hljs-javadoc{color:#006a00}.hljs-keyword,.hljs-literal,.nginx .hljs-title{color:#aa0d91}.hljs-list .hljs-title,.hljs-request,.hljs-status,.hljs-tag .hljs-title,.hljs-winutils,.http .hljs-title,.method,.setting .hljs-value,.tex .hljs-command{color:#008}.hljs-envvar,.tex .hljs-special{color:#660}.hljs-string{color:#c41a16}.apache .hljs-cbracket,.hljs-attr_selector,.hljs-cdata,.hljs-date,.hljs-filter .hljs-argument,.hljs-regexp,.hljs-tag .hljs-value{color:#080}.coffeescript .hljs-attribute,.css .hljs-function,.hljs-decorator,.hljs-function .hljs-title,.hljs-hexcolor,.hljs-number,.hljs-pi,.hljs-prompt,.hljs-rules .hljs-value,.hljs-shebang,.hljs-sub .hljs-identifier,.hljs-symbol,.hljs-symbol .hljs-string,.hljs-tag,.hljs-tag .hljs-keyword,.ini .hljs-title{color:#1c00cf}.clojure .hljs-attribute,.hljs-built_in,.hljs-class .hljs-id,.hljs-class .hljs-title,.hljs-dartdoc,.hljs-doctype,.hljs-javadoctag,.hljs-params,.hljs-phpdoc,.hljs-tag .hljs-attribute,.hljs-type,.hljs-typename,.hljs-yardoctag,.setting,.smalltalk .hljs-class{color:#5c2699}.hljs-variable{color:#3f6e74}.css .hljs-tag,.hljs-pseudo,.hljs-rules .hljs-property,.hljs-subst{color:#000}.css .hljs-class,.css .hljs-id{color:#9b703f}.hljs-value .hljs-important{color:#f70;font-weight:700}.hljs-rules .hljs-keyword{color:#c5af75}.apache .hljs-sqbracket,.hljs-annotation,.nginx .hljs-built_in{color:#9b859d}.hljs-pragma,.hljs-preprocessor,.hljs-preprocessor *{color:#643820}.tex .hljs-formula{background-color:#eee;font-style:italic}.diff .hljs-header,.hljs-chunk{color:gray;font-weight:700}.diff .hljs-change{background-color:#bccff9}.hljs-addition{background-color:#baeeba}.hljs-deletion{background-color:#ffc8bd}.hljs-comment .hljs-yardoctag{font-weight:700}.method .hljs-id{color:#000}.MathJax_Hover_Frame{border-radius:.25em;-webkit-border-radius:.25em;-moz-border-radius:.25em;-khtml-border-radius:.25em;box-shadow:0 0 15px #83A;-webkit-box-shadow:0 0 15px #83A;-moz-box-shadow:0 0 15px #83A;-khtml-box-shadow:0 0 15px #83A;border:1px solid #A6D!important;display:inline-block;position:absolute}.MathJax_Hover_Arrow{position:absolute;width:15px;height:11px;cursor:pointer}#MathJax_About{position:fixed;left:50%;width:auto;text-align:center;border:3px outset;padding:1em 2em;background-color:#DDD;color:#000;cursor:default;font-family:message-box;font-size:120%;font-style:normal;text-indent:0;text-transform:none;line-height:normal;letter-spacing:normal;word-spacing:normal;word-wrap:normal;white-space:nowrap;float:none;z-index:201;border-radius:15px;-webkit-border-radius:15px;-moz-border-radius:15px;-khtml-border-radius:15px;box-shadow:0 10px 20px gray;-webkit-box-shadow:0 10px 20px gray;-moz-box-shadow:0 10px 20px gray;-khtml-box-shadow:0 10px 20px gray;filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}.MathJax_Menu{position:absolute;background-color:#fff;color:#000;width:auto;padding:2px;border:1px solid #CCC;margin:0;cursor:default;font:menu;text-align:left;text-indent:0;text-transform:none;line-height:normal;letter-spacing:normal;word-spacing:normal;word-wrap:normal;white-space:nowrap;float:none;z-index:201;box-shadow:0 10px 20px gray;-webkit-box-shadow:0 10px 20px gray;-moz-box-shadow:0 10px 20px gray;-khtml-box-shadow:0 10px 20px gray;filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}.MathJax_MenuItem{padding:2px 2em;background:0 0}.MathJax_MenuArrow{position:absolute;right:.5em;color:#666}.MathJax_MenuActive .MathJax_MenuArrow{color:#fff}.MathJax_MenuArrow.RTL{left:.5em;right:auto}.MathJax_MenuCheck{position:absolute;left:.7em}.MathJax_MenuCheck.RTL{right:.7em;left:auto}.MathJax_MenuRadioCheck{position:absolute;left:1em}.MathJax_MenuRadioCheck.RTL{right:1em;left:auto}.MathJax_MenuLabel{padding:2px 2em 4px 1.33em;font-style:italic}.MathJax_MenuRule{border-top:1px solid #CCC;margin:4px 1px 0}.MathJax_MenuDisabled{color:GrayText}.MathJax_MenuActive{background-color:Highlight;color:HighlightText}.MathJax_Menu_Close{position:absolute;width:31px;height:31px;top:-15px;left:-15px}#MathJax_Zoom{position:absolute;background-color:#F0F0F0;overflow:auto;display:block;z-index:301;padding:.5em;border:1px solid #000;margin:0;font-weight:400;font-style:normal;text-align:left;text-indent:0;text-transform:none;line-height:normal;letter-spacing:normal;word-spacing:normal;word-wrap:normal;white-space:nowrap;float:none;box-shadow:5px 5px 15px #AAA;-webkit-box-shadow:5px 5px 15px #AAA;-moz-box-shadow:5px 5px 15px #AAA;-khtml-box-shadow:5px 5px 15px #AAA;filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}#MathJax_ZoomOverlay{position:absolute;left:0;top:0;z-index:300;display:inline-block;width:100%;height:100%;border:0;padding:0;margin:0;background-color:#fff;opacity:0;filter:alpha(opacity=0)}#MathJax_ZoomFrame{position:relative;display:inline-block;height:0;width:0}#MathJax_ZoomEventTrap{position:absolute;left:0;top:0;z-index:302;display:inline-block;border:0;padding:0;margin:0;background-color:#fff;opacity:0;filter:alpha(opacity=0)}.MathJax_Preview{color:#888}#MathJax_Message{position:fixed;left:1px;bottom:2px;background-color:#E6E6E6;border:1px solid #959595;margin:0;padding:2px 8px;z-index:102;color:#000;font-size:80%;width:auto;white-space:nowrap}#MathJax_MSIE_Frame{position:absolute;top:0;left:0;width:0;z-index:101;border:0;margin:0;padding:0}.MathJax_Error{color:#C00;font-style:italic}footer{position:fixed;font-size:.8em;text-align:right;bottom:0;margin-left:-25px;height:20px;width:100%}</style>
</head>
<body class="markdown solarized-light">
<h2 id="sesc源码阅读——caches"><a name="sesc源码阅读——caches" href="#sesc源码阅读——caches"></a>SESC源码阅读——Caches</h2><hr class="page"><h4 id="4.caches"><a name="4.caches" href="#4.caches"></a>4.Caches</h4><p>典型的现代微处理器中含有一个高层的指令高速缓冲存储器(I-cache)和一个高层的数据高速缓冲存储器(D-cache)。这两个cache也被称为L1 cache。在L1 cache之下，是相对较慢的L2 cache。在许多配置中，也存在一个off-die L3 cache(其比L2 cache更大、更慢)。caches拥有许多参数，SESC可以模拟不同种类的cache：</p><ul>
<li>cache大小</li><li>命中/缺失延迟</li><li>替换策略</li><li>缓存行(cache-line)大小</li><li>关联方式</li></ul><p>可想而知，要模型化涉及cache的所有的延迟和事务，SESC中cache的实现必然是非常复杂的，而且使用了许多事件驱动回调（因为在cache和bus中的实际延迟是不可预测的，所以CallBack类及其子类使得程序设计者可以在将来某个特定的时间上调度函数的调用。也只有回调机制可以保证周期精确的模拟结果。系统维护一个回调队列，每个回调对象产生后便会被插入到该队列中。回调对象记录了调用对象、其调用的成员函数、函数参数、调用周期点等。）。</p><pre class="bash hljs"><code class="Bash" data-origin="<pre><code class=&quot;Bash&quot;>例如：  

1) 一个L1的读缺失可能导致L1中一个脏的cache-line被写回到L2，并且仅仅当这些完成后L1 缺失才会被发送到L2。  

2) 然后，如果读缺失发生在L2中，L2需要经仲裁访问总线，最后发送缺失到内存，等等。  

3) 这其中的每一步都会导致一个固定的延迟和仲裁损失（对于同一资源，可能有许多请求，这时便需要仲裁，而仲裁会导致损失）。
</code></pre>">例如：  

<span class="hljs-number">1</span>) 一个L1的读缺失可能导致L1中一个脏的cache-line被写回到L2，并且仅仅当这些完成后L1 缺失才会被发送到L2。  

<span class="hljs-number">2</span>) 然后，如果读缺失发生在L2中，L2需要经仲裁访问总线，最后发送缺失到内存，等等。  

<span class="hljs-number">3</span>) 这其中的每一步都会导致一个固定的延迟和仲裁损失（对于同一资源，可能有许多请求，这时便需要仲裁，而仲裁会导致损失）。
</code></pre><h5 id="4.1-gprocessor类"><a name="4.1-gprocessor类" href="#4.1-gprocessor类"></a>4.1 GProcessor类</h5><pre class="java hljs"><code class="Java" data-origin="<pre><code class=&quot;Java&quot;>//src/libcore/GProcessor.h
class GProcessor {
private:
protected:
  // Per instance data
  const CPU_t Id;
  const int32_t FetchWidth;
  const int32_t IssueWidth;
  const int32_t RetireWidth;
  const int32_t RealisticWidth;
  const int32_t InstQueueSize;
  bool InOrderCore;
  const size_t MaxFlows;
  const size_t MaxROBSize;

  GMemorySystem *memorySystem;

  FastQueue&amp;lt;DInst *&amp;gt; ROB;

  FastQueue&amp;lt;DInst *&amp;gt; replayQ;
  LDSTQ lsq;
  //......
}
</code></pre>"><span class="hljs-comment">//src/libcore/GProcessor.h</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GProcessor</span> </span>{
<span class="hljs-keyword">private</span>:
<span class="hljs-keyword">protected</span>:
  <span class="hljs-comment">// Per instance data</span>
  <span class="hljs-keyword">const</span> CPU_t Id;
  <span class="hljs-keyword">const</span> int32_t FetchWidth;
  <span class="hljs-keyword">const</span> int32_t IssueWidth;
  <span class="hljs-keyword">const</span> int32_t RetireWidth;
  <span class="hljs-keyword">const</span> int32_t RealisticWidth;
  <span class="hljs-keyword">const</span> int32_t InstQueueSize;
  bool InOrderCore;
  <span class="hljs-keyword">const</span> size_t MaxFlows;
  <span class="hljs-keyword">const</span> size_t MaxROBSize;

  GMemorySystem *memorySystem;

  FastQueue&lt;DInst *&gt; ROB;

  FastQueue&lt;DInst *&gt; replayQ;
  LDSTQ lsq;
  <span class="hljs-comment">//......</span>
}
</code></pre><p>每一个GProcessor都拥有一个MemorySystem对象。MemorySystem对象创建一个分层的cache结构，并作为一个适配器服务于GProcessor和最高层的Caches之间,如下图所示。  </p><p><img src="/images/posts/sesc-cache00.png" alt="adapter">  </p><p>当GProcessor需要与MemorySystem交互时，它产生一个MemoryRequest对象（对于数据，其为DMemoryRequest对象；对于指令，其为IMemoryRequest对象）。</p><h5 id="4.2-dmemrequest类和imemrequest类"><a name="4.2-dmemrequest类和imemrequest类" href="#4.2-dmemrequest类和imemrequest类"></a>4.2 DMemRequest类和IMemRequest类</h5><pre class="go hljs"><code class="Go" data-origin="<pre><code class=&quot;Go&quot;>//src/libcore/MemRequest.h
class DMemRequest : public MemRequest {
  // MemRequest specialized for dcache
 private:
  static pool&amp;lt;DMemRequest, true&amp;gt; actPool;
  friend class pool&amp;lt;DMemRequest, true&amp;gt;;

  void destroy();
  static void dinstAck(DInst *dinst, MemOperation memOp, TimeDelta_t lat);

 protected:
 public:
  static void create(DInst *dinst, GMemorySystem *gmem, MemOperation mop);

  VAddr getVaddr() const;
  void ack(TimeDelta_t lat);
};

class IMemRequest : public MemRequest {
  // MemRequest specialed for icache
 private:
  static pool&amp;lt;IMemRequest, true&amp;gt; actPool;
  friend class pool&amp;lt;IMemRequest, true&amp;gt;;

  IBucket *buffer;

  void destroy();

 protected:
 public:
  static void create(DInst *dinst, GMemorySystem *gmem, IBucket *buffer);

  VAddr getVaddr() const;
  void ack(TimeDelta_t lat);
};
</code></pre>"><span class="hljs-comment">//src/libcore/MemRequest.h</span>
class DMemRequest : public MemRequest {
  <span class="hljs-comment">// MemRequest specialized for dcache</span>
 private:
  static pool&lt;DMemRequest, <span class="hljs-constant">true</span>&gt; actPool;
  friend class pool&lt;DMemRequest, <span class="hljs-constant">true</span>&gt;;

  void destroy();
  static void dinstAck(DInst *dinst, MemOperation memOp, TimeDelta_t lat);

 protected:
 public:
  static void create(DInst *dinst, GMemorySystem *gmem, MemOperation mop);

  VAddr getVaddr() <span class="hljs-keyword">const</span>;
  void ack(TimeDelta_t lat);
};

class IMemRequest : public MemRequest {
  <span class="hljs-comment">// MemRequest specialed for icache</span>
 private:
  static pool&lt;IMemRequest, <span class="hljs-constant">true</span>&gt; actPool;
  friend class pool&lt;IMemRequest, <span class="hljs-constant">true</span>&gt;;

  IBucket *buffer;

  void destroy();

 protected:
 public:
  static void create(DInst *dinst, GMemorySystem *gmem, IBucket *buffer);

  VAddr getVaddr() <span class="hljs-keyword">const</span>;
  void ack(TimeDelta_t lat);
};
</code></pre><p>DMemoryRequest比IMemoryRequest多了一个dinstAck()函数，其用来区分一个访问是读还是写。<br>MemoryRequest对象通过单一例化函数DMemRequest::create()或IMemRequest::create()创建:</p><pre class="java hljs"><code class="Java" data-origin="<pre><code class=&quot;Java&quot;>//src/libcore/MemRequest.cpp
void DMemRequest::create(DInst *dinst, GMemorySystem *gmem, MemOperation mop)
{
  // turn off address translation
  int32_t old_addr = dinst-&amp;gt;getVaddr();

#if !((defined TRACE_DRIVEN)||(defined QEMU_DRIVEN))
#if (defined MIPS_EMUL)
  ThreadContext *context=dinst-&amp;gt;context;
#else
  ThreadContext *context=ThreadContext::getMainThreadContext();
#endif
  if(!context-&amp;gt;isValidDataVAddr(old_addr)){
    dinstAck(dinst, mop, 0);
    return;
  }
#endif

  DMemRequest *r = actPool.out();//从Pool中分配一个新的MemRequest对象

  I(dinst != 0);//dinst == 0，输出一些信息

  IS(r-&amp;gt;acknowledged = false);//执行r-&amp;gt;acknowledged = false赋值操作
  I(r-&amp;gt;memStack.empty());//r-&amp;gt;memStack不为空，输出信息
  r-&amp;gt;currentClockStamp = (Time_t) -1;

  r-&amp;gt;setFields(dinst, mop, gmem-&amp;gt;getDataSource());//gmem是传进来的被访问的对象，该函数设置当前访问的内存对象currentMemObj
  r-&amp;gt;dataReq = true;
  r-&amp;gt;prefetch= false;
  r-&amp;gt;priority = 0;
#ifdef TLS
  r-&amp;gt;clearStall();
#endif

  int32_t ph_addr = gmem-&amp;gt;getMemoryOS()-&amp;gt;TLBTranslate(old_addr);
  if (ph_addr == -1) {
    gmem-&amp;gt;getMemoryOS()-&amp;gt;solveRequest(r);
    return;
  }


  r-&amp;gt;setPAddr(ph_addr);
  r-&amp;gt;access();//调用最高层cache对象的access()函数
}
</code></pre>"><span class="hljs-comment">//src/libcore/MemRequest.cpp</span>
<span class="hljs-keyword">void</span> DMemRequest::create(DInst *dinst, GMemorySystem *gmem, MemOperation mop)
{
  <span class="hljs-comment">// turn off address translation</span>
  int32_t old_addr = dinst-&gt;getVaddr();

#<span class="hljs-keyword">if</span> !((defined TRACE_DRIVEN)||(defined QEMU_DRIVEN))
#<span class="hljs-keyword">if</span> (defined MIPS_EMUL)
  ThreadContext *context=dinst-&gt;context;
#<span class="hljs-keyword">else</span>
  ThreadContext *context=ThreadContext::getMainThreadContext();
#<span class="hljs-function">endif
  <span class="hljs-title">if</span><span class="hljs-params">(!context-&gt;isValidDataVAddr(old_addr)</span>)</span>{
    dinstAck(dinst, mop, <span class="hljs-number">0</span>);
    <span class="hljs-keyword">return</span>;
  }
#endif

  DMemRequest *r = actPool.out();<span class="hljs-comment">//从Pool中分配一个新的MemRequest对象</span>

  I(dinst != <span class="hljs-number">0</span>);<span class="hljs-comment">//dinst == 0，输出一些信息</span>

  IS(r-&gt;acknowledged = <span class="hljs-keyword">false</span>);<span class="hljs-comment">//执行r-&gt;acknowledged = false赋值操作</span>
  I(r-&gt;memStack.empty());<span class="hljs-comment">//r-&gt;memStack不为空，输出信息</span>
  r-&gt;currentClockStamp = (Time_t) -<span class="hljs-number">1</span>;

  r-&gt;setFields(dinst, mop, gmem-&gt;getDataSource());<span class="hljs-comment">//gmem是传进来的被访问的对象，该函数设置当前访问的内存对象currentMemObj</span>
  r-&gt;dataReq = <span class="hljs-keyword">true</span>;
  r-&gt;prefetch= <span class="hljs-keyword">false</span>;
  r-&gt;priority = <span class="hljs-number">0</span>;
#ifdef TLS
  r-&gt;clearStall();
#endif

  int32_t ph_addr = gmem-&gt;getMemoryOS()-&gt;TLBTranslate(old_addr);
  <span class="hljs-keyword">if</span> (ph_addr == -<span class="hljs-number">1</span>) {
    gmem-&gt;getMemoryOS()-&gt;solveRequest(r);
    <span class="hljs-keyword">return</span>;
  }


  r-&gt;setPAddr(ph_addr);
  r-&gt;access();<span class="hljs-comment">//调用最高层cache对象的access()函数</span>
}
</code></pre><pre class="java hljs"><code class="Java" data-origin="<pre><code class=&quot;Java&quot;>static pool&amp;lt;DMemRequest, true&amp;gt; actPool;

template&amp;lt;class Ttype, bool noTimeCheck=false&amp;gt;
class pool {
//......
}
</code></pre>"><span class="hljs-keyword">static</span> pool&lt;DMemRequest, <span class="hljs-keyword">true</span>&gt; actPool;

template&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ttype</span>, <span class="hljs-title">bool</span> <span class="hljs-title">noTimeCheck</span></span>=<span class="hljs-keyword">false</span>&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">pool</span> </span>{
<span class="hljs-comment">//......</span>
}
</code></pre><pre class="java hljs"><code class="Java" data-origin="<pre><code class=&quot;Java&quot;>void MemRequest::access()
{
  currentMemObj-&amp;gt;access(this);
}

//src/libcore/MemoryRequest.h
void setFields(DInst *d, MemOperation mop, MemObj *mo) {
    dinst = d;
    if(d) {
      if(d-&amp;gt;getResource())
    gproc = d-&amp;gt;getResource()-&amp;gt;getCluster()-&amp;gt;getGProcessor();
    } else {
      gproc = 0;
    }
    memOp = mop;
    currentMemObj = mo;//设置当前访问的内存对象
}
</code></pre>"><span class="hljs-keyword">void</span> MemRequest::access()
{
  currentMemObj-&gt;access(<span class="hljs-keyword">this</span>);
}

<span class="hljs-comment">//src/libcore/MemoryRequest.h</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setFields</span><span class="hljs-params">(DInst *d, MemOperation mop, MemObj *mo)</span> </span>{
    dinst = d;
    <span class="hljs-keyword">if</span>(d) {
      <span class="hljs-keyword">if</span>(d-&gt;getResource())
    gproc = d-&gt;getResource()-&gt;getCluster()-&gt;getGProcessor();
    } <span class="hljs-keyword">else</span> {
      gproc = <span class="hljs-number">0</span>;
    }
    memOp = mop;
    currentMemObj = mo;<span class="hljs-comment">//设置当前访问的内存对象</span>
}
</code></pre><pre class="java hljs"><code class="Java" data-origin="<pre><code class=&quot;Java&quot;>#define IN(aC)   do{ int32_t aRes=0; aC; if(!aRes) doassert(); }while(0)
#define I(aC)    do{                 if(!(aC)) doassert(); }while(0)
#define GIN(g,e) do{ if(g) IN(e); }while(0)
#define GI(g,e)  do{ if(g)  I(e); }while(0)
#define GIS(g,e) do{ if(g)   e;   }while(0)
#define ID(e)        e
#define ID2(e)        e
#define IS(e)    do{ e;           }while(0)
</code></pre>">#<span class="hljs-function">define <span class="hljs-title">IN</span><span class="hljs-params">(aC)</span>   do</span>{ int32_t aRes=<span class="hljs-number">0</span>; aC; <span class="hljs-keyword">if</span>(!aRes) doassert(); }<span class="hljs-keyword">while</span>(<span class="hljs-number">0</span>)
#<span class="hljs-function">define <span class="hljs-title">I</span><span class="hljs-params">(aC)</span>    do</span>{                 <span class="hljs-keyword">if</span>(!(aC)) doassert(); }<span class="hljs-keyword">while</span>(<span class="hljs-number">0</span>)
#<span class="hljs-function">define <span class="hljs-title">GIN</span><span class="hljs-params">(g,e)</span> do</span>{ <span class="hljs-keyword">if</span>(g) IN(e); }<span class="hljs-keyword">while</span>(<span class="hljs-number">0</span>)
#<span class="hljs-function">define <span class="hljs-title">GI</span><span class="hljs-params">(g,e)</span>  do</span>{ <span class="hljs-keyword">if</span>(g)  I(e); }<span class="hljs-keyword">while</span>(<span class="hljs-number">0</span>)
#<span class="hljs-function">define <span class="hljs-title">GIS</span><span class="hljs-params">(g,e)</span> do</span>{ <span class="hljs-keyword">if</span>(g)   e;   }<span class="hljs-keyword">while</span>(<span class="hljs-number">0</span>)
#<span class="hljs-function">define <span class="hljs-title">ID</span><span class="hljs-params">(e)</span>        e
#define <span class="hljs-title">ID2</span><span class="hljs-params">(e)</span>        e
#define <span class="hljs-title">IS</span><span class="hljs-params">(e)</span>    do</span>{ e;           }<span class="hljs-keyword">while</span>(<span class="hljs-number">0</span>)
</code></pre><pre class="java hljs"><code class="Java" data-origin="<pre><code class=&quot;Java&quot;>#ifdef NANASSERTFILE
#define doassert()               \
    do {                                   \
      fprintf(ASSERTSTREAM,&quot;%s (%s),%s line %d failed for &quot;,__FILE__,NANASSERTFILE,NanassertID,__LINE__); \
      fprintf(ASSERTSTREAM,&quot;\n&quot;);          \
      ASSERTACTION;                        \
    }while(0)
#else
#define doassert()               \
    do {                                   \
      fprintf(ASSERTSTREAM,&quot;%s,%s line %d failed for &quot;,__FILE__,NanassertID,__LINE__);\
      fprintf(ASSERTSTREAM,&quot;\n&quot;);          \
      ASSERTACTION;                        \
    }while(0)
#endif
</code></pre>">#ifdef NANASSERTFILE
#<span class="hljs-function">define <span class="hljs-title">doassert</span><span class="hljs-params">()</span>               \
    do </span>{                                   \
      fprintf(ASSERTSTREAM,<span class="hljs-string">"%s (%s),%s line %d failed for "</span>,<span class="hljs-number">__F</span>ILE__,NANASSERTFILE,NanassertID,<span class="hljs-number">__L</span>INE__); \
      fprintf(ASSERTSTREAM,<span class="hljs-string">"\n"</span>);          \
      ASSERTACTION;                        \
    }<span class="hljs-keyword">while</span>(<span class="hljs-number">0</span>)
#<span class="hljs-keyword">else</span>
#<span class="hljs-function">define <span class="hljs-title">doassert</span><span class="hljs-params">()</span>               \
    do </span>{                                   \
      fprintf(ASSERTSTREAM,<span class="hljs-string">"%s,%s line %d failed for "</span>,<span class="hljs-number">__F</span>ILE__,NanassertID,<span class="hljs-number">__L</span>INE__);\
      fprintf(ASSERTSTREAM,<span class="hljs-string">"\n"</span>);          \
      ASSERTACTION;                        \
    }<span class="hljs-keyword">while</span>(<span class="hljs-number">0</span>)
#endif
</code></pre><p>DMemRequest::create()函数的参数是请求关联的DInst对象、将要访问的MemorySystem对象和操作类型(读或写)。<br>create()函数分配一个新的MemRequest对象，并初始化它，最后调用最高层cache对象的access()函数。  </p><h5 id="4.3-cache类"><a name="4.3-cache类" href="#4.3-cache类"></a>4.3 Cache类</h5><pre class="java hljs"><code class="Java" data-origin="<pre><code class=&quot;Java&quot;>//src/libmem/Cache.cpp
void Cache::access(MemRequest *mreq) 
{
  mreq-&amp;gt;setClockStamp((Time_t) - 1);
  if(mreq-&amp;gt;getPAddr() &amp;lt;= 1024) { // TODO: need to implement support for fences
    mreq-&amp;gt;goUp(0); 
    return;
  }

  nAccesses[getBankId(mreq-&amp;gt;getPAddr())]-&amp;gt;inc();

  switch(mreq-&amp;gt;getMemOperation()){
  case MemReadW:
  case MemRead:    read(mreq);       break;
  case MemWrite:   write(mreq);      break;
  case MemPush:    pushLine(mreq);   break;
  default:         specialOp(mreq);  break;
  }
}

//读

void Cache::read(MemRequest *mreq)
{ 
#ifdef MSHR_BWSTATS
  if(parallelMSHR)
    mshrBWHist.inc();
#endif
  //enforcing max ops/cycle for the specific bank
  doReadBankCB::scheduleAbs(nextBankSlot(mreq-&amp;gt;getPAddr()), this, mreq);
}
void Cache::doReadBank(MemRequest *mreq)
{ 
  // enforcing max ops/cycle for the whole cache
  doReadCB::scheduleAbs(nextCacheSlot(), this, mreq);
}
void Cache::doRead(MemRequest *mreq)
{
  Line *l = getCacheBank(mreq-&amp;gt;getPAddr())-&amp;gt;readLine(mreq-&amp;gt;getPAddr());

  if (l == 0) {
    if(isInWBuff(mreq-&amp;gt;getPAddr())) {
      nForwarded.inc();
      mreq-&amp;gt;goUp(fwdDelay);
      return;
    }
    readMissHandler(mreq);
    return;
  }

  readHit.inc();
  l-&amp;gt;incReadAccesses();

  mreq-&amp;gt;goUp(hitDelay);
}

//写

void Cache::write(MemRequest *mreq)
{ 
#ifdef MSHR_BWSTATS
  if(parallelMSHR)
    mshrBWHist.inc();
#endif
  doWriteBankCB::scheduleAbs(nextBankSlot(mreq-&amp;gt;getPAddr()), this, mreq);
}
void Cache::doWriteBank(MemRequest *mreq)
{
  doWriteCB::scheduleAbs(nextCacheSlot(), this, mreq);
}

void Cache::doWrite(MemRequest *mreq)
{
  Line *l = getCacheBank(mreq-&amp;gt;getPAddr())-&amp;gt;writeLine(mreq-&amp;gt;getPAddr());

  if (l == 0) {
    writeMissHandler(mreq);
    return;
  }

  writeHit.inc();
  l-&amp;gt;makeDirty();

  mreq-&amp;gt;goUp(hitDelay);
}
</code></pre>"><span class="hljs-comment">//src/libmem/Cache.cpp</span>
<span class="hljs-keyword">void</span> Cache::access(MemRequest *mreq) 
{
  mreq-&gt;setClockStamp((Time_t) - <span class="hljs-number">1</span>);
  <span class="hljs-keyword">if</span>(mreq-&gt;getPAddr() &lt;= <span class="hljs-number">1024</span>) { <span class="hljs-comment">// TODO: need to implement support for fences</span>
    mreq-&gt;goUp(<span class="hljs-number">0</span>); 
    <span class="hljs-keyword">return</span>;
  }

  nAccesses[getBankId(mreq-&gt;getPAddr())]-&gt;inc();

  <span class="hljs-keyword">switch</span>(mreq-&gt;getMemOperation()){
  <span class="hljs-keyword">case</span> MemReadW:
  <span class="hljs-keyword">case</span> MemRead:    read(mreq);       <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> MemWrite:   write(mreq);      <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> MemPush:    pushLine(mreq);   <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">default</span>:         specialOp(mreq);  <span class="hljs-keyword">break</span>;
  }
}

<span class="hljs-comment">//读</span>

<span class="hljs-keyword">void</span> Cache::read(MemRequest *mreq)
{ 
#<span class="hljs-function">ifdef MSHR_BWSTATS
  <span class="hljs-title">if</span><span class="hljs-params">(parallelMSHR)</span>
    mshrBWHist.<span class="hljs-title">inc</span><span class="hljs-params">()</span></span>;
#endif
  <span class="hljs-comment">//enforcing max ops/cycle for the specific bank</span>
  doReadBankCB::scheduleAbs(nextBankSlot(mreq-&gt;getPAddr()), <span class="hljs-keyword">this</span>, mreq);
}
<span class="hljs-keyword">void</span> Cache::doReadBank(MemRequest *mreq)
{ 
  <span class="hljs-comment">// enforcing max ops/cycle for the whole cache</span>
  doReadCB::scheduleAbs(nextCacheSlot(), <span class="hljs-keyword">this</span>, mreq);
}
<span class="hljs-keyword">void</span> Cache::doRead(MemRequest *mreq)
{
  Line *l = getCacheBank(mreq-&gt;getPAddr())-&gt;readLine(mreq-&gt;getPAddr());

  <span class="hljs-keyword">if</span> (l == <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">if</span>(isInWBuff(mreq-&gt;getPAddr())) {
      nForwarded.inc();
      mreq-&gt;goUp(fwdDelay);
      <span class="hljs-keyword">return</span>;
    }
    readMissHandler(mreq);
    <span class="hljs-keyword">return</span>;
  }

  readHit.inc();
  l-&gt;incReadAccesses();

  mreq-&gt;goUp(hitDelay);
}

<span class="hljs-comment">//写</span>

<span class="hljs-keyword">void</span> Cache::write(MemRequest *mreq)
{ 
#<span class="hljs-function">ifdef MSHR_BWSTATS
  <span class="hljs-title">if</span><span class="hljs-params">(parallelMSHR)</span>
    mshrBWHist.<span class="hljs-title">inc</span><span class="hljs-params">()</span></span>;
#endif
  doWriteBankCB::scheduleAbs(nextBankSlot(mreq-&gt;getPAddr()), <span class="hljs-keyword">this</span>, mreq);
}
<span class="hljs-keyword">void</span> Cache::doWriteBank(MemRequest *mreq)
{
  doWriteCB::scheduleAbs(nextCacheSlot(), <span class="hljs-keyword">this</span>, mreq);
}

<span class="hljs-keyword">void</span> Cache::doWrite(MemRequest *mreq)
{
  Line *l = getCacheBank(mreq-&gt;getPAddr())-&gt;writeLine(mreq-&gt;getPAddr());

  <span class="hljs-keyword">if</span> (l == <span class="hljs-number">0</span>) {
    writeMissHandler(mreq);
    <span class="hljs-keyword">return</span>;
  }

  writeHit.inc();
  l-&gt;makeDirty();

  mreq-&gt;goUp(hitDelay);
}
</code></pre><pre class="swift hljs"><code class="Swift" data-origin="<pre><code class=&quot;Swift&quot;>//src/libmem/Cache.h
//该回调是一个对类Cache成员函数doRead()的调用，其参数仅有一个，且类型为MemRequest *。
  typedef CallbackMember1&amp;lt;Cache, MemRequest *, &amp;amp;Cache::doRead&amp;gt; 
    doReadCB;
  typedef CallbackMember1&amp;lt;Cache, MemRequest *, &amp;amp;Cache::doWrite&amp;gt; 
    doWriteCB;
</code></pre>"><span class="hljs-comment">//src/libmem/Cache.h</span>
<span class="hljs-comment">//该回调是一个对类Cache成员函数doRead()的调用，其参数仅有一个，且类型为MemRequest *。</span>
  typedef <span class="hljs-type">CallbackMember1</span>&lt;<span class="hljs-type">Cache</span>, <span class="hljs-type">MemRequest</span> *, &amp;<span class="hljs-type">Cache</span>::doRead&gt; 
    doReadCB;
  typedef <span class="hljs-type">CallbackMember1</span>&lt;<span class="hljs-type">Cache</span>, <span class="hljs-type">MemRequest</span> *, &amp;<span class="hljs-type">Cache</span>::doWrite&gt; 
    doWriteCB;
</code></pre><p>在Cache对象中，access()函数是非常简单的，它发送读请求给read()函数和发送写请求给write()函数。每一个函数都使用一个回调以在下一个可获得的Cache周期中调用doRead()或doWrite()函数，这样可以模型化cache端口的竞争。如果读(写)在doRead()函数(doWrite()函数)是命中的，传进来的MemoryRequest对象参数的goUp()函数会被调用。这将会返回MemoryRequest给GProcessor。否则，一个miss处理函数将被调用，它会调用MemRequest对象的goDown()函数，并将MemRequest发送到层次结构中的下一级(如bus或L3 cache)。</p><pre class="java hljs"><code class="Java" data-origin="<pre><code class=&quot;Java&quot;>//src/libmem/Cache.cpp
void Cache::readMissHandler(MemRequest *mreq)
{
  //......
  // Added a new MSHR entry, now send request to lower level
  readMiss.inc();
  sendMiss(mreq);
}

void WBCache::sendMiss(MemRequest *mreq)
{

  //......
  mreq-&amp;gt;goDown(missDelay + (nextMSHRSlot(mreq-&amp;gt;getPAddr())-globalClock), 
               lowerLevel[0]);
}
</code></pre>"><span class="hljs-comment">//src/libmem/Cache.cpp</span>
<span class="hljs-keyword">void</span> Cache::readMissHandler(MemRequest *mreq)
{
  <span class="hljs-comment">//......</span>
  <span class="hljs-comment">// Added a new MSHR entry, now send request to lower level</span>
  readMiss.inc();
  sendMiss(mreq);
}

<span class="hljs-keyword">void</span> WBCache::sendMiss(MemRequest *mreq)
{

  <span class="hljs-comment">//......</span>
  mreq-&gt;goDown(missDelay + (nextMSHRSlot(mreq-&gt;getPAddr())-globalClock), 
               lowerLevel[<span class="hljs-number">0</span>]);
}
</code></pre><pre class="java hljs"><code class="Java" data-origin="<pre><code class=&quot;Java&quot;>//src/libcore/MemRequest.h
  void goDown(TimeDelta_t lat, MemObj *newMemObj) {
    memStack.push(currentMemObj);
    clockStack.push(globalClock);
//......
    currentMemObj = newMemObj;
    accessCB.schedule(lat);
  }
</code></pre>"><span class="hljs-comment">//src/libcore/MemRequest.h</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">goDown</span><span class="hljs-params">(TimeDelta_t lat, MemObj *newMemObj)</span> </span>{
    memStack.push(currentMemObj);
    clockStack.push(globalClock);
<span class="hljs-comment">//......</span>
    currentMemObj = newMemObj;
    accessCB.schedule(lat);
  }
</code></pre><h5 id="4.4-注意点"><a name="4.4-注意点" href="#4.4-注意点"></a>4.4 注意点</h5><pre class="java hljs"><code class="Java" data-origin="<pre><code class=&quot;Java&quot;>class MemObj {
public:
  typedef std::vector&amp;lt;MemObj*&amp;gt; LevelType;
private:
  bool highest;

protected:

  uint32_t nUpperCaches;
  LevelType upperLevel;
  LevelType lowerLevel;

  const char *descrSection;
  const char *symbolicName;

  void addLowerLevel(MemObj *obj) { 
    I( obj );
    lowerLevel.push_back(obj);
    obj-&amp;gt;addUpperLevel(this);
  }

  void addUpperLevel(MemObj *obj) { 
    upperLevel.push_back(obj);
  }

  void invUpperLevel(PAddr addr, ushort size, MemObj *oc) {

    I(oc);

     for(uint32_t i=0; i&amp;lt;upperLevel.size(); i++)
      upperLevel[i]-&amp;gt;invalidate(addr, size, oc);    
  }
public:
//.....
  void computenUpperCaches();

  //This assumes single entry point for object, which I do not like,
  //but it is still something that is worthwhile.
  virtual Time_t getNextFreeCycle() const = 0;

  virtual void access(MemRequest *mreq) = 0;
  virtual void returnAccess(MemRequest *mreq) = 0;

  virtual void invalidate(PAddr addr, ushort size, MemObj *oc) = 0;
  virtual void doInvalidate(PAddr addr, ushort size) { I(0); }

  typedef CallbackMember2&amp;lt;MemObj, PAddr, ushort,
                         &amp;amp;MemObj::doInvalidate&amp;gt; doInvalidateCB;

  // When the buffers in the cache are full and it does not accept more requests
  virtual bool canAcceptStore(PAddr addr) = 0;
  virtual bool canAcceptLoad(PAddr addr) { return true; }

  // Print stats
  virtual void dump() const;
};
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MemObj</span> </span>{
<span class="hljs-keyword">public</span>:
  typedef std::vector&lt;MemObj*&gt; LevelType;
<span class="hljs-keyword">private</span>:
  bool highest;

<span class="hljs-keyword">protected</span>:

  uint32_t nUpperCaches;
  LevelType upperLevel;
  LevelType lowerLevel;

  <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *descrSection;
  <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *symbolicName;

  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addLowerLevel</span><span class="hljs-params">(MemObj *obj)</span> </span>{ 
    I( obj );
    lowerLevel.push_back(obj);
    obj-&gt;addUpperLevel(<span class="hljs-keyword">this</span>);
  }

  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addUpperLevel</span><span class="hljs-params">(MemObj *obj)</span> </span>{ 
    upperLevel.push_back(obj);
  }

  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">invUpperLevel</span><span class="hljs-params">(PAddr addr, ushort size, MemObj *oc)</span> </span>{

    I(oc);

     <span class="hljs-keyword">for</span>(uint32_t i=<span class="hljs-number">0</span>; i&lt;upperLevel.size(); i++)
      upperLevel[i]-&gt;invalidate(addr, size, oc);    
  }
<span class="hljs-keyword">public</span>:
<span class="hljs-comment">//.....</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">computenUpperCaches</span><span class="hljs-params">()</span></span>;

  <span class="hljs-comment">//This assumes single entry point for object, which I do not like,</span>
  <span class="hljs-comment">//but it is still something that is worthwhile.</span>
  <span class="hljs-function">virtual Time_t <span class="hljs-title">getNextFreeCycle</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>= <span class="hljs-number">0</span>;

  <span class="hljs-function">virtual <span class="hljs-keyword">void</span> <span class="hljs-title">access</span><span class="hljs-params">(MemRequest *mreq)</span> </span>= <span class="hljs-number">0</span>;
  <span class="hljs-function">virtual <span class="hljs-keyword">void</span> <span class="hljs-title">returnAccess</span><span class="hljs-params">(MemRequest *mreq)</span> </span>= <span class="hljs-number">0</span>;

  <span class="hljs-function">virtual <span class="hljs-keyword">void</span> <span class="hljs-title">invalidate</span><span class="hljs-params">(PAddr addr, ushort size, MemObj *oc)</span> </span>= <span class="hljs-number">0</span>;
  <span class="hljs-function">virtual <span class="hljs-keyword">void</span> <span class="hljs-title">doInvalidate</span><span class="hljs-params">(PAddr addr, ushort size)</span> </span>{ I(<span class="hljs-number">0</span>); }

  typedef CallbackMember2&lt;MemObj, PAddr, ushort,
                         &amp;MemObj::doInvalidate&gt; doInvalidateCB;

  <span class="hljs-comment">// When the buffers in the cache are full and it does not accept more requests</span>
  <span class="hljs-function">virtual bool <span class="hljs-title">canAcceptStore</span><span class="hljs-params">(PAddr addr)</span> </span>= <span class="hljs-number">0</span>;
  <span class="hljs-function">virtual bool <span class="hljs-title">canAcceptLoad</span><span class="hljs-params">(PAddr addr)</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>; }

  <span class="hljs-comment">// Print stats</span>
  <span class="hljs-function">virtual <span class="hljs-keyword">void</span> <span class="hljs-title">dump</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;
};
</code></pre><ul>
<li>所有的Cache类和Bus类都是继承自MemObj类。MemObj类定义了一个公有的接口，如access()、returnAccess()和其他一些不太重要的函数。</li><li>当访问从一个较低层的cache返回到一个较高层的cache时，goUp()函数会调用returnAccess()函数。</li><li>公有接口允许完整的可配置cache层次结构。</li></ul>

<footer style="position:fixed; font-size:.8em; text-align:right; bottom:0px; margin-left:-25px; height:20px; width:100%;">generated by <a href="http://pad.haroopress.com" target="_blank">haroopad</a></footer>
</body>
</html>
