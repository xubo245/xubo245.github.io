---
layout:     post
title:      "页缓存和块缓存"
subtitle:   "Linux的内存管理"
date:       2016-04-15
author:     "yuchen"
header-img: "img/post-bg-odroid.jpg"
tags:
    - Linux
    - Kernel
    - Memory
---
<!DOCTYPE html>
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<title>页缓存和块缓存</title>
    <!--mark |wiz_custom_css| for wizeditor replace it-->


<style id="wiz_custom_css">        html, body {            font-size: 15px;        }        body {            font-family: Helvetica, 'Hiragino Sans GB', '微软雅黑', 'Microsoft YaHei UI', SimSun, SimHei, arial, sans-serif;            line-height: 1.6;            margin: 0;            padding: 20px 36px;            padding: 1.33rem 2.4rem;        }        h1, h2, h3, h4, h5, h6 {            margin: 20px 0 10px;            margin: 1.33rem 0 0.667rem;            padding: 0;            font-weight: bold;        }        h1 {            font-size: 21px;            font-size: 1.4rem;        }        h2 {            font-size: 20px;            font-size: 1.33rem;        }        h3 {            font-size: 18px;            font-size: 1.2rem;        }        h4 {            font-size: 17px;            font-size: 1.13rem;        }        h5 {            font-size: 15px;            font-size: 1rem;        }        h6 {            font-size: 15px;            font-size: 1rem;            color: #777777;            margin: 1rem 0;        }        div, p, ul, ol, dl, li {            margin: 0;        }        blockquote, table, pre, code {            margin: 8px 0;        }        ul, ol {            padding-left: 32px;            padding-left: 2.13rem;        }        blockquote {            padding: 0 12px;            padding: 0 0.8rem;        }        blockquote > :first-child {            margin-top: 0;        }        blockquote > :last-child {            margin-bottom: 0;        }        img {            border: 0;            max-width: 100%;            height: auto !important;            margin: 2px 0;        }        table {            border-collapse: collapse;            border: 1px solid #bbbbbb;        }        td {            padding: 4px 8px;            border-collapse: collapse;            border: 1px solid #bbbbbb;        }        @media screen and (max-width: 660px) {            body {                padding: 20px 18px;                padding: 1.33rem 1.2rem;            }        }        @media only screen and (-webkit-max-device-width: 1024px), only screen and (-o-max-device-width: 1024px), only screen and (max-device-width: 1024px), only screen and (-webkit-min-device-pixel-ratio: 3), only screen and (-o-min-device-pixel-ratio: 3), only screen and (min-device-pixel-ratio: 3) {            html, body {                font-size: 17px;            }            body {                line-height: 1.7;                padding: 0.75rem 0.9375rem;                color: #353c47;            }            h1 {                font-size: 2.125rem;            }            h2 {                font-size: 1.875rem;            }            h3 {                font-size: 1.625rem;            }            h4 {                font-size: 1.375rem;            }            h5 {                font-size: 1.125rem;            }            h6 {                color: inherit;            }            ul, ol {                padding-left: 2.5rem;            }            blockquote {                padding: 0 0.9375rem;            }        }</style><style type="text/css" id="wiz_todo_style_id" wiz_link_version="01.00.09">.wiz-todo, .wiz-todo-img {width: 16px; height: 16px; cursor: default; padding: 0 10px 0 2px; vertical-align: -10%;-webkit-user-select: none;} .wiz-todo-label { display: inline-block; padding-top: 7px; padding-bottom: 6px; line-height: 1.5;} .wiz-todo-label-checked {  color: #666;} .wiz-todo-label-unchecked {text-decoration: initial;} .wiz-todo-completed-info {padding-left: 44px; display: inline-block; } .wiz-todo-avatar { width:20px; height: 20px; vertical-align: -20%; margin-right:10px; border-radius: 2px;} .wiz-todo-account, .wiz-todo-dt { color: #666; }</style><link rel="stylesheet" href="/wiz/github2.css" charset="utf-8"><link rel="stylesheet" href="/wiz/wizToc.css" charset="utf-8"></head>

<body style="" class="markdown-body"><h2 id="wiz_toc_0">独立的缓冲区–LRU块缓存</h2>

<hr>

<h5 id="wiz_toc_1">1.操作方式</h5>

<ul>
<li>为什么采用LRU？ <br>
LRU代表最近最少使用（least recently used），指的是一种一般方法，可用于有效管理一个集合中最常使用的那些成员。如果经常访问一个数据元素，则该元素很可能位于物理内存中（因而被缓存）。较不常用或很少使用的数据元素，将随时间的推移，逐渐自动退出缓存。</li>
<li>实现基本原理： <br>
上一次使用的数据元素，将由内核自动放置到LRU列表的第一个位置上。如果缓存中已经有数据元素，则只改变各个元素的位置。如果该数据元素是从块设备读取的，则将数组的最后一个元素退出缓存，从内存中释放。</li>
</ul>

<h5 id="wiz_toc_2">2.实现–数据结构</h5>

<blockquote>
  <p>数据结构</p>
</blockquote>

<p>实现的起点是bh_lru结构，其定义如下：</p>

<pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code class="language-C++"><span class="pln">fs</span><span class="pun">/</span><span class="pln">buffer</span><span class="pun">.</span><span class="pln">c</span></code></li><li class="L1"><code class="language-C++"><span class="com">#define</span><span class="pln"> BH_LRU_SIZE </span><span class="lit">8</span></code></li><li class="L2"><code class="language-C++"></code></li><li class="L3"><code class="language-C++"><span class="kwd">struct</span><span class="pln"> bh_lru </span><span class="pun">{</span></code></li><li class="L4"><code class="language-C++"><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> buffer_head </span><span class="pun">*</span><span class="pln">bhs</span><span class="pun">[</span><span class="pln">BH_LRU_SIZE</span><span class="pun">];</span></code></li><li class="L5"><code class="language-C++"><span class="pun">};</span></code></li><li class="L6"><code class="language-C++"><span class="kwd">static</span><span class="pln"> DEFINE_PER_CPU</span><span class="pun">(</span><span class="kwd">struct</span><span class="pln"> bh_lru</span><span class="pun">,</span><span class="pln"> bh_lrus</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{{</span><span class="pln"> NULL </span><span class="pun">}};</span></code></li></ol></pre>

<p>bhs是一个缓冲头指针的数组，用作实现LRU算法的基础（按定义所示，其中包括8个数据项）。内核使用DEFINE_PER_CPU，为系统的每个CPU都建立一个实例，改进对CPU高速缓存的利用率。</p>

<h5 id="wiz_toc_3">3.实现–两个公开的函数（通过内核提供）</h5>

<ul>
<li>lookup_bh_lru检查所需数据项是否在缓存中：</li>
</ul>

<pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code class="language-C++"><span class="com">/*</span></code></li><li class="L1"><code class="language-C++"><span class="com"> * Look up the bh in this cpu's LRU.  If it's there, move it to the head.</span></code></li><li class="L2"><code class="language-C++"><span class="com"> */</span></code></li><li class="L3"><code class="language-C++"><span class="kwd">static</span><span class="pln"> </span><span class="kwd">struct</span><span class="pln"> buffer_head </span><span class="pun">*</span></code></li><li class="L4"><code class="language-C++"><span class="pln">lookup_bh_lru</span><span class="pun">(</span><span class="kwd">struct</span><span class="pln"> block_device </span><span class="pun">*</span><span class="pln">bdev</span><span class="pun">,</span><span class="pln"> </span><span class="typ">sector_t</span><span class="pln"> block</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">unsigned</span><span class="pln"> size</span><span class="pun">)</span></code></li><li class="L5"><code class="language-C++"><span class="pun">{</span></code></li><li class="L6"><code class="language-C++"><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> buffer_head </span><span class="pun">*</span><span class="pln">ret </span><span class="pun">=</span><span class="pln"> NULL</span><span class="pun">;</span></code></li><li class="L7"><code class="language-C++"><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> bh_lru </span><span class="pun">*</span><span class="pln">lru</span><span class="pun">;</span></code></li><li class="L8"><code class="language-C++"><span class="pln">    </span><span class="kwd">unsigned</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> i</span><span class="pun">;</span></code></li><li class="L9"><code class="language-C++"></code></li><li class="L0"><code class="language-C++"><span class="pln">    check_irqs_on</span><span class="pun">();</span><span class="com">//如果定义了关中断，则关闭中断</span></code></li><li class="L1"><code class="language-C++"><span class="pln">    bh_lru_lock</span><span class="pun">();</span><span class="com">//加锁，实质是关闭本地中断</span></code></li><li class="L2"><code class="language-C++"><span class="pln">    lru </span><span class="pun">=</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">__get_cpu_var</span><span class="pun">(</span><span class="pln">bh_lrus</span><span class="pun">);</span><span class="com">//根据当前CPU选择对应的数组</span></code></li><li class="L3"><code class="language-C++"><span class="pln">    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="pln">i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> BH_LRU_SIZE</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L4"><code class="language-C++"><span class="pln">        </span><span class="kwd">struct</span><span class="pln"> buffer_head </span><span class="pun">*</span><span class="pln">bh </span><span class="pun">=</span><span class="pln"> lru</span><span class="pun">-&gt;</span><span class="pln">bhs</span><span class="pun">[</span><span class="pln">i</span><span class="pun">];</span></code></li><li class="L5"><code class="language-C++"><span class="pln">        </span><span class="com">//条件成立即表示所需数据在缓存中</span></code></li><li class="L6"><code class="language-C++"><span class="pln">        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">bh </span><span class="pun">&amp;&amp;</span><span class="pln"> bh</span><span class="pun">-&gt;</span><span class="pln">b_bdev </span><span class="pun">==</span><span class="pln"> bdev </span><span class="pun">&amp;&amp;</span></code></li><li class="L7"><code class="language-C++"><span class="pln">                bh</span><span class="pun">-&gt;</span><span class="pln">b_blocknr </span><span class="pun">==</span><span class="pln"> block </span><span class="pun">&amp;&amp;</span><span class="pln"> bh</span><span class="pun">-&gt;</span><span class="pln">b_size </span><span class="pun">==</span><span class="pln"> size</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L8"><code class="language-C++"><span class="pln">            </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">i</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="com">//i为0，则不需要做任何操作</span></code></li><li class="L9"><code class="language-C++"><span class="pln">                </span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(</span><span class="pln">i</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L0"><code class="language-C++"><span class="pln">                </span><span class="com">//将i前的所有数组元素都往右一个下标</span></code></li><li class="L1"><code class="language-C++"><span class="pln">                    lru</span><span class="pun">-&gt;</span><span class="pln">bhs</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> lru</span><span class="pun">-&gt;</span><span class="pln">bhs</span><span class="pun">[</span><span class="pln">i </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">];</span></code></li><li class="L2"><code class="language-C++"><span class="pln">                    i</span><span class="pun">--;</span></code></li><li class="L3"><code class="language-C++"><span class="pln">                </span><span class="pun">}</span></code></li><li class="L4"><code class="language-C++"><span class="pln">                </span><span class="com">//将数组的首元素置为所查找的数据项</span></code></li><li class="L5"><code class="language-C++"><span class="pln">                lru</span><span class="pun">-&gt;</span><span class="pln">bhs</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> bh</span><span class="pun">;</span></code></li><li class="L6"><code class="language-C++"><span class="pln">            </span><span class="pun">}</span></code></li><li class="L7"><code class="language-C++"><span class="pln">            get_bh</span><span class="pun">(</span><span class="pln">bh</span><span class="pun">);</span></code></li><li class="L8"><code class="language-C++"><span class="pln">            ret </span><span class="pun">=</span><span class="pln"> bh</span><span class="pun">;</span></code></li><li class="L9"><code class="language-C++"><span class="pln">            </span><span class="kwd">break</span><span class="pun">;</span></code></li><li class="L0"><code class="language-C++"><span class="pln">        </span><span class="pun">}</span></code></li><li class="L1"><code class="language-C++"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L2"><code class="language-C++"><span class="pln">    bh_lru_unlock</span><span class="pun">();</span></code></li><li class="L3"><code class="language-C++"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> ret</span><span class="pun">;</span></code></li><li class="L4"><code class="language-C++"><span class="pun">}</span></code></li></ol></pre>

<ul>
<li>bh_lru_install将新的缓冲头添加到缓存中：</li>
</ul>

<pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code class="language-C++"><span class="com">/*</span></code></li><li class="L1"><code class="language-C++"><span class="com"> * The LRU management algorithm is dopey-but-simple.  Sorry.</span></code></li><li class="L2"><code class="language-C++"><span class="com"> */</span></code></li><li class="L3"><code class="language-C++"><span class="kwd">static</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> bh_lru_install</span><span class="pun">(</span><span class="kwd">struct</span><span class="pln"> buffer_head </span><span class="pun">*</span><span class="pln">bh</span><span class="pun">)</span></code></li><li class="L4"><code class="language-C++"><span class="pun">{</span></code></li><li class="L5"><code class="language-C++"><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> buffer_head </span><span class="pun">*</span><span class="pln">evictee </span><span class="pun">=</span><span class="pln"> NULL</span><span class="pun">;</span></code></li><li class="L6"><code class="language-C++"><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> bh_lru </span><span class="pun">*</span><span class="pln">lru</span><span class="pun">;</span></code></li><li class="L7"><code class="language-C++"></code></li><li class="L8"><code class="language-C++"><span class="pln">    check_irqs_on</span><span class="pun">();</span></code></li><li class="L9"><code class="language-C++"><span class="pln">    bh_lru_lock</span><span class="pun">();</span></code></li><li class="L0"><code class="language-C++"><span class="pln">    lru </span><span class="pun">=</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">__get_cpu_var</span><span class="pun">(</span><span class="pln">bh_lrus</span><span class="pun">);</span></code></li><li class="L1"><code class="language-C++"><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">lru</span><span class="pun">-&gt;</span><span class="pln">bhs</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">!=</span><span class="pln"> bh</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="com">//查找新的数据项是否一致lru列表的首项中，不在则继续</span></code></li><li class="L2"><code class="language-C++"><span class="pln">        </span><span class="kwd">struct</span><span class="pln"> buffer_head </span><span class="pun">*</span><span class="pln">bhs</span><span class="pun">[</span><span class="pln">BH_LRU_SIZE</span><span class="pun">];</span><span class="com">//新定义一个与lru列表相同的数组，作为临时数组，作拷贝之用</span></code></li><li class="L3"><code class="language-C++"><span class="pln">        </span><span class="kwd">int</span><span class="pln"> </span><span class="kwd">in</span><span class="pun">;</span></code></li><li class="L4"><code class="language-C++"><span class="pln">        </span><span class="kwd">int</span><span class="pln"> </span><span class="kwd">out</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span></code></li><li class="L5"><code class="language-C++"></code></li><li class="L6"><code class="language-C++"><span class="pln">        get_bh</span><span class="pun">(</span><span class="pln">bh</span><span class="pun">);</span><span class="com">//将bh的引用计数器加1，原子操作</span></code></li><li class="L7"><code class="language-C++"><span class="pln">        bhs</span><span class="pun">[</span><span class="kwd">out</span><span class="pun">++]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> bh</span><span class="pun">;</span><span class="com">//将临时数组的首元素置为新的缓冲头,out此时值为1</span></code></li><li class="L8"><code class="language-C++"><span class="pln">        </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">in</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> </span><span class="kwd">in</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln"> BH_LRU_SIZE</span><span class="pun">;</span><span class="pln"> </span><span class="kwd">in</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L9"><code class="language-C++"><span class="pln">        </span><span class="com">//获得lru列表中的每一个元素</span></code></li><li class="L0"><code class="language-C++"><span class="pln">            </span><span class="kwd">struct</span><span class="pln"> buffer_head </span><span class="pun">*</span><span class="pln">bh2 </span><span class="pun">=</span><span class="pln"> lru</span><span class="pun">-&gt;</span><span class="pln">bhs</span><span class="pun">[</span><span class="kwd">in</span><span class="pun">];</span></code></li><li class="L1"><code class="language-C++"><span class="pln">        </span><span class="com">//如果lru列表中有一项与新的缓冲头相同，则释放该项（其实是将其引用计数器减1），并重新循环</span></code></li><li class="L2"><code class="language-C++"><span class="pln">            </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">bh2 </span><span class="pun">==</span><span class="pln"> bh</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L3"><code class="language-C++"><span class="pln">                __brelse</span><span class="pun">(</span><span class="pln">bh2</span><span class="pun">);</span></code></li><li class="L4"><code class="language-C++"><span class="pln">            </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L5"><code class="language-C++"><span class="pln">                </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">out</span><span class="pln"> </span><span class="pun">&gt;=</span><span class="pln"> BH_LRU_SIZE</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="com">//此处为true说明lru已经满了，故而应该删除列表的最后一项（根据LRU原则，将lru列表的最后一项赋给eviotee，后面会被释放）</span></code></li><li class="L6"><code class="language-C++"><span class="pln">                    BUG_ON</span><span class="pun">(</span><span class="pln">evictee </span><span class="pun">!=</span><span class="pln"> NULL</span><span class="pun">);</span></code></li><li class="L7"><code class="language-C++"><span class="pln">                    evictee </span><span class="pun">=</span><span class="pln"> bh2</span><span class="pun">;</span></code></li><li class="L8"><code class="language-C++"><span class="pln">                </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L9"><code class="language-C++"><span class="pln">                </span><span class="com">//将lru列表中的元素拷贝到临时数组中</span></code></li><li class="L0"><code class="language-C++"><span class="pln">                    bhs</span><span class="pun">[</span><span class="kwd">out</span><span class="pun">++]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> bh2</span><span class="pun">;</span><span class="com">//out总比in大1</span></code></li><li class="L1"><code class="language-C++"><span class="pln">                </span><span class="pun">}</span></code></li><li class="L2"><code class="language-C++"><span class="pln">            </span><span class="pun">}</span></code></li><li class="L3"><code class="language-C++"><span class="pln">        </span><span class="pun">}</span></code></li><li class="L4"><code class="language-C++"><span class="pln">        </span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">out</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln"> BH_LRU_SIZE</span><span class="pun">)</span></code></li><li class="L5"><code class="language-C++"><span class="pln">            bhs</span><span class="pun">[</span><span class="kwd">out</span><span class="pun">++]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> NULL</span><span class="pun">;</span><span class="com">//将临时数组的最后一个有用项之后一项赋为null，为memcpy做准备。</span></code></li><li class="L6"><code class="language-C++"><span class="pln">        memcpy</span><span class="pun">(</span><span class="pln">lru</span><span class="pun">-&gt;</span><span class="pln">bhs</span><span class="pun">,</span><span class="pln"> bhs</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">sizeof</span><span class="pun">(</span><span class="pln">bhs</span><span class="pun">));</span></code></li><li class="L7"><code class="language-C++"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L8"><code class="language-C++"><span class="pln">    bh_lru_unlock</span><span class="pun">();</span></code></li><li class="L9"><code class="language-C++"><span class="pln">    </span><span class="com">//释放原lru列表的最后一项</span></code></li><li class="L0"><code class="language-C++"><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">evictee</span><span class="pun">)</span></code></li><li class="L1"><code class="language-C++"><span class="pln">        __brelse</span><span class="pun">(</span><span class="pln">evictee</span><span class="pun">);</span></code></li><li class="L2"><code class="language-C++"><span class="pun">}</span></code></li></ol></pre>

<h5 id="wiz_toc_4">4.接口函数</h5>

<p><strong>注意</strong>：如果lookup_bh_lru失败，不会自动从块设备读取所需的块。而是通过下列接口函数完成： <br>
普通的内核代码通常不会接触到bh_lookup_lru或bh_lru_install，因为二者被封装起来。内核提供了通用例程来访问各个块，它们自动涵盖了块缓存，使得没必要与块缓存进行显式交互。这些例程包括__getblk和__bread。</p>

<h6 id="wiz_toc_5">两个函数的相同点：</h6>

<ul>
<li>函数原型相同，可以这样描述：</li>
</ul>

<pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code class="language-C++"><span class="pln">typedf </span><span class="kwd">struct</span><span class="pln"> buffer_head </span><span class="pun">(</span><span class="pln">get_read</span><span class="pun">)(</span><span class="kwd">struct</span><span class="pln"> block_device </span><span class="pun">*</span><span class="pln">bdev</span><span class="pun">,</span><span class="pln"> </span><span class="typ">sector_t</span><span class="pln"> block</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">unsigned</span><span class="pln"> size</span><span class="pun">)；</span></code></li><li class="L1"><code class="language-C++"><span class="pln">get_read</span><span class="pun">*</span><span class="pln"> __getblk</span><span class="pun">;</span></code></li><li class="L2"><code class="language-C++"><span class="pln">get_read</span><span class="pun">*</span><span class="pln"> __bread</span><span class="pun">;</span></code></li></ol></pre>

<p>数据块可通过所在块设备的block_device实例、扇区编号（sector_t类型）和块长度唯一标识。</p>

<h6 id="wiz_toc_6">两个函数的不同点(不同点与两个函数的目标有关)：</h6>

<ul>
<li>__bread保证返回一个包含最新数据的缓冲区。这导致在必要的情况下，需要读取底层块设备。</li>
<li>调用__getblk总是返回一个非NULL指针（即一个缓冲头）。如果所要缓冲区的数据已经在内存中，则返回数据，但不保证数据的状态。与__bread相比，数据可能不是最新的。而另一种可能性是，缓冲区对应的块尚未读入内存。在这种情况下，__getblk确保分配数据所需的内存空间，并将缓冲头插入到LRU缓存。</li>
</ul>

<h5 id="wiz_toc_7">5.__getblk函数</h5>

<p>因为__bread会调用__getblk，所以我们先看一下__getblk的代码流程图： <br>
<img src="/images/posts/blk00.png" alt="__getblk代码流程图" title=""> <br>
在执行__getblk时有两条执行路径：  </p>

<p>1)调用__find_get_block使用如下所述的方法来查找所要的缓冲区。如果查找成功则返回一个buffer_head实例。否则，任务委托给__getblk_slow。  </p>

<p>2)__getblk_slow能产生所要的缓冲区，但用时比__find_get_block长。但该函数能够保证总是可以返回一个适当的buffer_head实例并为数据分配内存空间。  </p>

<p>最后，__getblk函数使用bh_lru_install将其将缓冲头插入到块缓存，而touch_buffer对与缓冲区相关的页调用了mark_page_accessed方法（参见第18章）。 <br>
代码如下:</p>

<pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code class="language-C++"><span class="kwd">struct</span><span class="pln"> buffer_head </span><span class="pun">*</span></code></li><li class="L1"><code class="language-C++"><span class="pln">__getblk</span><span class="pun">(</span><span class="kwd">struct</span><span class="pln"> block_device </span><span class="pun">*</span><span class="pln">bdev</span><span class="pun">,</span><span class="pln"> </span><span class="typ">sector_t</span><span class="pln"> block</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">unsigned</span><span class="pln"> size</span><span class="pun">)</span></code></li><li class="L2"><code class="language-C++"><span class="pun">{</span></code></li><li class="L3"><code class="language-C++"><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> buffer_head </span><span class="pun">*</span><span class="pln">bh </span><span class="pun">=</span><span class="pln"> __find_get_block</span><span class="pun">(</span><span class="pln">bdev</span><span class="pun">,</span><span class="pln"> block</span><span class="pun">,</span><span class="pln"> size</span><span class="pun">);</span></code></li><li class="L4"><code class="language-C++"></code></li><li class="L5"><code class="language-C++"><span class="pln">    might_sleep</span><span class="pun">();</span></code></li><li class="L6"><code class="language-C++"><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">bh </span><span class="pun">==</span><span class="pln"> NULL</span><span class="pun">)</span><span class="com">//__find_get_block发挥null，则进入__getblk_slow，该函数保证至少会分配缓冲头和实际数据所需的内存空间。</span></code></li><li class="L7"><code class="language-C++"><span class="pln">        bh </span><span class="pun">=</span><span class="pln"> __getblk_slow</span><span class="pun">(</span><span class="pln">bdev</span><span class="pun">,</span><span class="pln"> block</span><span class="pun">,</span><span class="pln"> size</span><span class="pun">);</span></code></li><li class="L8"><code class="language-C++"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> bh</span><span class="pun">;</span></code></li><li class="L9"><code class="language-C++"><span class="pun">}</span></code></li><li class="L0"><code class="language-C++"></code></li><li class="L1"><code class="language-C++"><span class="pln">EXPORT_SYMBOL</span><span class="pun">(</span><span class="pln">__getblk</span><span class="pun">);</span></code></li></ol></pre>

<pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code class="language-C++"><span class="kwd">struct</span><span class="pln"> buffer_head </span><span class="pun">*</span></code></li><li class="L1"><code class="language-C++"><span class="pln">__find_get_block</span><span class="pun">(</span><span class="kwd">struct</span><span class="pln"> block_device </span><span class="pun">*</span><span class="pln">bdev</span><span class="pun">,</span><span class="pln"> </span><span class="typ">sector_t</span><span class="pln"> block</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">unsigned</span><span class="pln"> size</span><span class="pun">)</span></code></li><li class="L2"><code class="language-C++"><span class="pun">{</span></code></li><li class="L3"><code class="language-C++"><span class="pln">    </span><span class="com">//调用lookup_bh_lru函数，检查所需的块是否已经在LRU缓存中</span></code></li><li class="L4"><code class="language-C++"><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> buffer_head </span><span class="pun">*</span><span class="pln">bh </span><span class="pun">=</span><span class="pln"> lookup_bh_lru</span><span class="pun">(</span><span class="pln">bdev</span><span class="pun">,</span><span class="pln"> block</span><span class="pun">,</span><span class="pln"> size</span><span class="pun">);</span></code></li><li class="L5"><code class="language-C++"></code></li><li class="L6"><code class="language-C++"><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">bh </span><span class="pun">==</span><span class="pln"> NULL</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L7"><code class="language-C++"><span class="pln">    </span><span class="com">//__find_get_block_slow函数试图在页缓存中查找该数据</span></code></li><li class="L8"><code class="language-C++"><span class="pln">        bh </span><span class="pun">=</span><span class="pln"> __find_get_block_slow</span><span class="pun">(</span><span class="pln">bdev</span><span class="pun">,</span><span class="pln"> block</span><span class="pun">);</span></code></li><li class="L9"><code class="language-C++"><span class="pln">    </span><span class="com">/*__find_get_block_slow试图在页缓存中查找该数据，这可以产生两个不同的结果:</span></code></li><li class="L0"><code class="language-C++"><span class="com">    1)如果数据不在页缓存中，或虽然在页缓存中，但对应的页没有与之关联的缓冲区，则返回一个NULL指针;</span></code></li><li class="L1"><code class="language-C++"><span class="com">    2)如果数据在页缓存中，且对应页有相关的缓冲区，则返回指向所要缓冲头的指针。</span></code></li><li class="L2"><code class="language-C++"><span class="com">    */</span></code></li><li class="L3"><code class="language-C++"><span class="pln">        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">bh</span><span class="pun">)</span><span class="com">//如果根据上述函数找到了缓冲头，则调用bh_lru_install函数将其添加到缓存。</span></code></li><li class="L4"><code class="language-C++"><span class="pln">            bh_lru_install</span><span class="pun">(</span><span class="pln">bh</span><span class="pun">);</span></code></li><li class="L5"><code class="language-C++"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L6"><code class="language-C++"><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">bh</span><span class="pun">)</span><span class="com">//所需块已经在LRU缓存中</span></code></li><li class="L7"><code class="language-C++"><span class="pln">        </span><span class="com">//touch_buffer会调用mark_page_accessed将该页标记为与缓存关联之后，内核返回到__getblk。</span></code></li><li class="L8"><code class="language-C++"><span class="pln">        touch_buffer</span><span class="pun">(</span><span class="pln">bh</span><span class="pun">);</span></code></li><li class="L9"><code class="language-C++"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> bh</span><span class="pun">;</span></code></li><li class="L0"><code class="language-C++"><span class="pun">}</span></code></li></ol></pre>

<pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code class="language-C++"><span class="kwd">static</span><span class="pln"> </span><span class="kwd">struct</span><span class="pln"> buffer_head </span><span class="pun">*</span></code></li><li class="L1"><code class="language-C++"><span class="pln">__getblk_slow</span><span class="pun">(</span><span class="kwd">struct</span><span class="pln"> block_device </span><span class="pun">*</span><span class="pln">bdev</span><span class="pun">,</span><span class="pln"> </span><span class="typ">sector_t</span><span class="pln"> block</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> size</span><span class="pun">)</span></code></li><li class="L2"><code class="language-C++"><span class="pun">{</span></code></li><li class="L3"><code class="language-C++"><span class="pln">    </span><span class="com">//...</span></code></li><li class="L4"><code class="language-C++"><span class="pln">    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(;;)</span><span class="pln"> </span><span class="pun">{</span><span class="com">//无限循环,内核试图反复在内存中创建数据结构，直至成功</span></code></li><li class="L5"><code class="language-C++"><span class="pln">        </span><span class="kwd">struct</span><span class="pln"> buffer_head </span><span class="pun">*</span><span class="pln"> bh</span><span class="pun">;</span></code></li><li class="L6"><code class="language-C++"><span class="pln">        </span><span class="kwd">int</span><span class="pln"> ret</span><span class="pun">;</span></code></li><li class="L7"><code class="language-C++"><span class="pln">        </span><span class="com">//再次调用__find_get_block函数，但是刚才明明已经调用失败，为何这样做？</span></code></li><li class="L8"><code class="language-C++"><span class="pln">        </span><span class="com">/*</span></code></li><li class="L9"><code class="language-C++"><span class="com">        原因：只有在与此同时有另一个CPU建立了所需的缓冲区，并在内存中创建了对</span></code></li><li class="L0"><code class="language-C++"><span class="com">        应的数据结构时，这一次函数调用才会成功。尽管这不太可能，但仍然必须检查。</span></code></li><li class="L1"><code class="language-C++"><span class="com">        */</span></code></li><li class="L2"><code class="language-C++"><span class="pln">        bh </span><span class="pun">=</span><span class="pln"> __find_get_block</span><span class="pun">(</span><span class="pln">bdev</span><span class="pun">,</span><span class="pln"> block</span><span class="pun">,</span><span class="pln"> size</span><span class="pun">);</span></code></li><li class="L3"><code class="language-C++"><span class="pln">        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">bh</span><span class="pun">)</span></code></li><li class="L4"><code class="language-C++"><span class="pln">            </span><span class="kwd">return</span><span class="pln"> bh</span><span class="pun">;</span><span class="com">//如果这次调用成功(找到缓冲头)，则返回。</span></code></li><li class="L5"><code class="language-C++"><span class="pln">        </span><span class="com">//不成功，内核则调用grow_buffers，试图为缓冲头和实际数据分配内存，</span></code></li><li class="L6"><code class="language-C++"><span class="pln">        </span><span class="com">//并将该内存空间添加到内核的数据结构。</span></code></li><li class="L7"><code class="language-C++"><span class="pln">        ret </span><span class="pun">=</span><span class="pln"> grow_buffers</span><span class="pun">(</span><span class="pln">bdev</span><span class="pun">,</span><span class="pln"> block</span><span class="pun">,</span><span class="pln"> size</span><span class="pun">);</span></code></li><li class="L8"><code class="language-C++"><span class="pln">        </span><span class="com">//调用grow_buffers会返回三种结果：</span></code></li><li class="L9"><code class="language-C++"><span class="pln">        </span><span class="com">/*</span></code></li><li class="L0"><code class="language-C++"><span class="com">        （1）如果成功（ret&gt;0），则再次调用__find_get_block，这一次会返回</span></code></li><li class="L1"><code class="language-C++"><span class="com">        所要所要的buffer_head。</span></code></li><li class="L2"><code class="language-C++"><span class="com">        （2）如果对grow_buffers的调用返回负值，这意味着块超出了页缓存索引</span></code></li><li class="L3"><code class="language-C++"><span class="com">        的范围，此时将放弃循环，因为目标块在物理上是不存在的。</span></code></li><li class="L4"><code class="language-C++"><span class="com">        （3）如果grow_buffers返回0，这意味着内存不足，无法增加缓冲区，</span></code></li><li class="L5"><code class="language-C++"><span class="com">        接下来调用free_more_memory试图释放更多的物理内存来改善这种状况</span></code></li><li class="L6"><code class="language-C++"><span class="com">        */</span></code></li><li class="L7"><code class="language-C++"><span class="pln">        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">ret </span><span class="pun">&lt;</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span></code></li><li class="L8"><code class="language-C++"><span class="pln">            </span><span class="kwd">return</span><span class="pln"> NULL</span><span class="pun">;</span></code></li><li class="L9"><code class="language-C++"><span class="pln">        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">ret </span><span class="pun">==</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span></code></li><li class="L0"><code class="language-C++"><span class="pln">            free_more_memory</span><span class="pun">();</span></code></li><li class="L1"><code class="language-C++"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L2"><code class="language-C++"><span class="pun">}</span></code></li></ol></pre>

<p>grow_buffers在进行一些正确性检查之后，它将工作委托给grow_dev_page函数，grow_dev_page函数的代码流程图如下：</p>

<p><img src="/images/posts/blk01.png" alt="grow_dev_page代码流程图" title="">  </p>

<p><strong>解释:</strong> <br>
1)find_or_create_page查找一个适当的页或创建一个新页，来保存数据。内存不足则返回NULL指针。  </p>

<p>2)如果页已经与长度正确的缓冲区相关联，通过init_page_buffers来修改剩余的缓冲区数据（b_bdev和b_blocknr），那么grow_dev_page就无事可做，可以退出。  </p>

<p>3）否则，使用alloc_page_buffers生成一组新的缓冲区，使用link_dev_buffers函数关联到页。而init_page_buffers用来填充缓冲头的状态（b_status）和管理数据（b_bdev、b_blocknr）。</p>

<h5 id="wiz_toc_8">6.__bread函数</h5>

<p>与__getblk函数不同，__bread确保返回一个数据最新的缓冲区。其实现代码如下：</p>

<pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code class="language-C++"><span class="kwd">struct</span><span class="pln"> buffer_head </span><span class="pun">*</span></code></li><li class="L1"><code class="language-C++"><span class="pln">__bread</span><span class="pun">(</span><span class="kwd">struct</span><span class="pln"> block_device </span><span class="pun">*</span><span class="pln">bdev</span><span class="pun">,</span><span class="pln"> </span><span class="typ">sector_t</span><span class="pln"> block</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">unsigned</span><span class="pln"> size</span><span class="pun">)</span></code></li><li class="L2"><code class="language-C++"><span class="pun">{</span></code></li><li class="L3"><code class="language-C++"><span class="com">//调用__getblk，确认缓冲头和实际数据所需的内存空间都已经就位。</span></code></li><li class="L4"><code class="language-C++"><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> buffer_head </span><span class="pun">*</span><span class="pln">bh </span><span class="pun">=</span><span class="pln"> __getblk</span><span class="pun">(</span><span class="pln">bdev</span><span class="pun">,</span><span class="pln"> block</span><span class="pun">,</span><span class="pln"> size</span><span class="pun">);</span></code></li><li class="L5"><code class="language-C++"></code></li><li class="L6"><code class="language-C++"><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">likely</span><span class="pun">(</span><span class="pln">bh</span><span class="pun">)</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> </span><span class="pun">!</span><span class="pln">buffer_uptodate</span><span class="pun">(</span><span class="pln">bh</span><span class="pun">))</span><span class="com">//缓冲的数据不是最新的</span></code></li><li class="L7"><code class="language-C++"><span class="pln">    </span><span class="com">//__bread_slow向块层提交一个请求，在物理上读取数据，并等待操作完成。</span></code></li><li class="L8"><code class="language-C++"><span class="pln">    </span><span class="com">//接下来，在缓冲区的数据保证为最新之后，返回缓冲头指针。</span></code></li><li class="L9"><code class="language-C++"><span class="pln">        bh </span><span class="pun">=</span><span class="pln"> __bread_slow</span><span class="pun">(</span><span class="pln">bh</span><span class="pun">);</span></code></li><li class="L0"><code class="language-C++"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> bh</span><span class="pun">;</span><span class="com">//如果缓冲的数据已经是最新的，则返回指向缓冲头的指针。</span></code></li><li class="L1"><code class="language-C++"><span class="pun">}</span></code></li></ol></pre>

<h5 id="wiz_toc_9">7.在文件系统中的使用</h5>

<p>内核中需要用到按块读取的方式的场景不多，但是用到处都很重要。特别是，文件系统在读取超级块或管理块时利用了上述的两个例程。 <br>
内核定义了两个函数，以简化文件系统处理单个块的工作：</p>

<pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code class="language-C++"><span class="tag">&lt;buffer_head.h&gt;</span></code></li><li class="L1"><code class="language-C++"><span class="pln">sb_bread(struct super_block *sb, sector_t block)</span></code></li><li class="L2"><code class="language-C++"><span class="pln">{</span></code></li><li class="L3"><code class="language-C++"><span class="pln">    return __bread(sb-&gt;s_bdev, block, sb-&gt;s_blocksize);</span></code></li><li class="L4"><code class="language-C++"><span class="pln">}</span></code></li><li class="L5"><code class="language-C++"></code></li><li class="L6"><code class="language-C++"><span class="pln">static inline struct buffer_head *</span></code></li><li class="L7"><code class="language-C++"><span class="pln">sb_getblk(struct super_block *sb, sector_t block)</span></code></li><li class="L8"><code class="language-C++"><span class="pln">{</span></code></li><li class="L9"><code class="language-C++"><span class="pln">    return __getblk(sb-&gt;s_bdev, block, sb-&gt;s_blocksize);</span></code></li><li class="L0"><code class="language-C++"><span class="pln">}</span></code></li></ol></pre>

<p>从代码中可以看出，用于读取特定文件系统的例程使用了一个超级块、一个块号和一个块长度作为参数。</p></body></html>